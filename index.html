<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Philip Munksgaard" />
  <meta name="dcterms.date" content="2021-03-23" />
  <title>Blue Noise in Futhark</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Blue Noise in Futhark</h1>
<p class="author">Philip Munksgaard</p>
<p class="date">March 23, 2021</p>
</header>
<h1 id="introduction">Introduction</h1>
<p>A while ago, I read Surma’s excellent article on <a href="https://surma.dev/things/ditherpunk/">dithering</a>. Immediately, it sparked my interest in the game <em>Return of the Obra Dinn</em>, which I’ve since enjoyed immensely. I also thought it would be fun to try to implement some of the dithering algorithms he’s describing in Futhark, but I never really got around to it. Until now!</p>
<p>I’ll mainly be focusing on the blue noise filter, as that seemed like the most interesting one, but I’ll also be implementing the Bayer filter and perhaps a few others. I’ll skip most of the details about how dithering works and what the purpose is, and instead direct you to the article linked above. The purpose of this post is to illustrate how we can implement the algorithms described using Futhark.</p>
<p>By the way, this blog post was written using <code>futhark literate</code> so you can inspect the entire source code at your leisure.</p>
<p>With all that out of the way, let’s dive in.</p>
<h1 id="images-and-greyscale-conversion">Images and greyscale conversion</h1>
<p>We’ll be using the same images as in Surma’s blog post:</p>
<figure>
<img src="dark-original.png" alt="A black-and-white photograph of San Francisco’s Golden Gate." /><figcaption aria-hidden="true">A black-and-white photograph of San Francisco’s Golden Gate.</figcaption>
</figure>
<figure>
<img src="light-original.png" alt="A black-and-white photograph of San Francisco’s Bay Bridge." /><figcaption aria-hidden="true">A black-and-white photograph of San Francisco’s Bay Bridge.</figcaption>
</figure>
<p>Loading images into futhark literate returns pixels in ARGB format in the form of <code>[][]u32</code>. We’re only interested in greyscale images, so let’s write a few functions to convert an ARGB image into greyscale. We’ll use <code>f32</code> values between 0 and 1 to represent greyscale, with 0 being black and 1 being white. We also immediately perform the gamma-correction, so we can meaningfully work with the greyscale images from now on.</p>
<pre class="futhark"><code>let unpack_rgb (pixel: u32): (u8, u8, u8) =
  (u8.u32 pixel,
   u8.u32 (pixel &gt;&gt; 8),
   u8.u32 (pixel &gt;&gt; 16))

let brightness (pixel: u32): f32 =
  let (r, g, b) = unpack_rgb pixel
  -- We could use just one of the channels, but this should give us the same
  -- result.
  in (f32.u8 r + f32.u8 g + f32.u8 b) / (255.0 * 3)

let to_linear (b: f32): f32 =
  if b &lt;= 0.04045 then
    b / 12.92
  else
    ((b + 0.055) / 1.055) ** 2.4

let greyscale [n][m] (img: [n][m]u32): [n][m]f32 =
  map (map (to_linear &lt;-&lt; brightness)) img</code></pre>
<h1 id="quantizing">Quantizing</h1>
<p>Now we can try to apply the simple quantization method of simply checking if each pixel is below or above 0.5 in order to determine if it should be black or white:</p>
<pre class="futhark"><code>let quantize [n][m] (img: [n][m]f32): [n][m]bool =
  map (map (\b -&gt; if b &gt; 0.5 then true else false)) img</code></pre>
<pre><code>&gt; :img quantize (greyscale ($loadimg &quot;dark-original.png&quot;))</code></pre>
<p><img src="bluenoise-img/e65e0cf22b1c21a-img.png" /></p>
<pre><code>&gt; :img quantize (greyscale ($loadimg &quot;light-original.png&quot;))</code></pre>
<p><img src="bluenoise-img/dd3ea9b33cb0f2a4-img.png" /></p>
<p>Note that I use booleans to represent pure black-and-white pixels: <code>true</code> is white and <code>false</code> is black.</p>
<p>As stated in the original article, this method is pretty unsatisfying. We can barely see what’s depicted.</p>
<p>Let’s try with random noise instead.</p>
<pre class="futhark"><code>import &quot;lib/github.com/diku-dk/cpprandom/random&quot;

module d = uniform_real_distribution f32 minstd_rand

let quantize_random [n][m] (seed: i32) (img: [n][m]f32): [n][m]bool =
  -- Create a rng per pixel
  let rngs = minstd_rand.rng_from_seed [seed]
             |&gt; minstd_rand.split_rng n
             |&gt; map (minstd_rand.split_rng m)
  -- For each pixel apply the randomness factor and quantize
  in map2 (map2 (\rng pixel -&gt;
                   let (_, x) = d.rand (0, 1) rng
                   in if pixel + (x - 0.5) &gt; 0.5
                      then true
                      else false))
          rngs img</code></pre>
<pre><code>&gt; :img quantize_random 123i32 (greyscale ($loadimg &quot;dark-original.png&quot;))</code></pre>
<p><img src="bluenoise-img/92d78ab679f1c206-img.png" /></p>
<pre><code>&gt; :img quantize_random 123i32 (greyscale ($loadimg &quot;light-original.png&quot;))</code></pre>
<p><img src="bluenoise-img/f67350e7932d6730-img.png" /></p>
<h1 id="dithering">Dithering</h1>
<p>Next we come to the dithering algorithsm. The first one is the Bayer dithering, which uses Bayer matrices.</p>
<p><code>concat_m</code> takes four equal-sized matrices and arranges them in a square matrix.</p>
<pre class="futhark"><code>let concat_m [n] &#39;t (xss1: [n][n]t) (xss2: [n][n]t) (xss3: [n][n]t) (xss4: [n][n]t): [][]t =
  let n2 = n * 2
  in concat (transpose (concat_to n2 (transpose xss1) (transpose xss2)))
            (transpose (concat_to n2 (transpose xss3) (transpose xss4)))</code></pre>
<p><code>bayer</code> computes the Bayer matrix of rank <code>n</code>.</p>
<pre class="futhark"><code>let bayer (n: i64): [][]i32 =
  let helper i = map (map (\x -&gt; 4 * x + i))
  let bayer = [[0, 2], [3, 1]]
  in if n == 0 then bayer
     else
       loop bayer for _ in 1 ... n do
         concat_m (helper 0 bayer)
                  (helper 2 bayer)
                  (helper 3 bayer)
                  (helper 1 bayer)</code></pre>
<p>Note that we should perhaps use the by bit-arithmetic method instead, or at least figure out which one is faster: https://en.wikipedia.org/wiki/Ordered_dithering</p>
<p>We’ll also need to be able to normalize Bayer filters (and later bluenoise filters). For that we’ll introduce <code>normalize</code>:</p>
<pre class="futhark"><code>let normalize [n][m] (xss: [n][m]i32): [n][m]f32 =
  let maximum = i32.maximum (map i32.maximum xss)
  in map (map (\x -&gt; f32.i32 x / f32.i32 maximum)) xss</code></pre>
<p>Finally, <code>dither</code> is the dithering function to apply a dither mask to an image.</p>
<pre class="futhark"><code>let dither [n1][m1][n2][m2] (img: [n1][m1]f32) (mask: [n2][m2]f32): [n1][m1]f32 =
  let helper i j pixel =
    if pixel &gt; mask[i % n2, j % m2]
    then 1.0
    else 0.0
  in map2 (\i -&gt; map2 (helper i) (iota m1))
          (iota n1) img</code></pre>
<p>Let’s see some results</p>
<pre class="futhark"><code>let bayer0 = normalize (bayer 0)
let bayer1 = normalize (bayer 1)
let bayer2 = normalize (bayer 2)
let bayer3 = normalize (bayer 3)</code></pre>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;dark-original.png&quot;)) bayer0</code></pre>
<p><img src="bluenoise-img/81e9f00437567054-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;light-original.png&quot;)) bayer0</code></pre>
<p><img src="bluenoise-img/9912f14ec12271a2-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;dark-original.png&quot;)) bayer1</code></pre>
<p><img src="bluenoise-img/81e9f004385671e7-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;light-original.png&quot;)) bayer1</code></pre>
<p><img src="bluenoise-img/9912f14ec2227335-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;dark-original.png&quot;)) bayer2</code></pre>
<p><img src="bluenoise-img/81e9f0043956737a-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;light-original.png&quot;)) bayer2</code></pre>
<p><img src="bluenoise-img/9912f14ebf226e7c-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;dark-original.png&quot;)) bayer3</code></pre>
<p><img src="bluenoise-img/81e9f0043a56750d-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;light-original.png&quot;)) bayer3</code></pre>
<p><img src="bluenoise-img/9912f14ec022700f-img.png" /></p>
<p>I think that looks pretty good!</p>
<h1 id="blue-noise">Blue noise</h1>
<p>Let’s move on to blue noise filters, which is another way of generating masks for dithering. It’s based on the <a href="https://www.spiedigitallibrary.org/conference-proceedings-of-spie/1913/0000/Void-and-cluster-method-for-dither-array-generation/10.1117/12.152707.pdf?casa_token=J16yJDRtYWcAAAAA:F4avF1zsEbK1aTUDjtQWXcEx9ixwE7IFB3ZicgBrhFdzeO_SrKHfXRg3p39C88ms_0LPdJ2-C4k">void-and-cluster method as originally described by Robert Ulichney</a>.</p>
<p>I’ve only implemented the naive version, which computes everyting in the spatial domain. I’ll see if I can’t get around to implementing the frequency-domain method that Surma described.</p>
<p>First, we need to be able to generate the input pattern, which is just a randomly generated binary pattern:</p>
<p>Now, for computing the gaussian, we need to choose a value for σ:</p>
<pre class="futhark"><code>let sigma: f32 = 1.5</code></pre>
<p>For the filter, we use the gaussian function suggested by Ulichney:</p>
<pre class="futhark"><code>let gaussian (x: i64) (y: i64): f32 =
  f32.e ** (- (f32.i64 x ** 2 + f32.i64 y ** 2) / (2 * sigma ** 2))</code></pre>
<p>The <code>dither_value</code> function is a straight-forward implementation of DA from the paper:</p>
<pre class="futhark"><code>let dither_value [M] (bp: [M][M]bool) (x: i64) (y: i64): f32 =
  map (\p -&gt;
         let p = p - M/2
         in map (\q -&gt;
                   let q = q - M / 2
                   let p&#39; = (M + x - p) % M
                   let q&#39; = (M + y - q) % M
                   in f32.bool bp[p&#39;, q&#39;] * gaussian p q)
                (iota M)
      )
      (iota M)
  |&gt; map f32.sum
  |&gt; f32.sum</code></pre>
<p>Having implemented <code>dither_value</code>, we can now implement the <code>tightest_cluster</code> and <code>largest_void</code> functions. Really, they are quite similar, and we could certainly abstract them out into one function, but keeping them separate makes it more clear what they do.</p>
<pre class="futhark"><code>let tightest_cluster [n] (inp: [n][n]bool): (i64, i64) =
  -- First compute, for each pixel in `inp`, the dither_value. Return also the
  -- indices for each pixel and its boolean value.
  map2 (\i row -&gt; map2 (\j v -&gt; ((i, j), v, dither_value inp i j))
                       (indices row)
                       row)
       (indices inp) inp
  -- Flatten the matrix so we are working on a single-dimensional array.
  |&gt; flatten
  -- Find the highest-valued pixel, considering only pixels that are `true` in
  -- the original input.
  |&gt; reduce_comm (\(idx, x, v) (idx&#39;, x&#39;, v&#39;) -&gt;
                    if v &gt; v&#39; || !x&#39;
                    then (idx, x, v)
                    else (idx&#39;, x&#39;, v&#39;))
                 ((-1, -1), false, f32.lowest)
  |&gt; (.0)

let largest_void [n] (inp: [n][n]bool): (i64, i64) =
  map2 (\i row -&gt; map2 (\j v -&gt; ((i, j), v, dither_value inp i j))
                       (indices row)
                       row)
       (indices inp) inp
  |&gt; flatten
  |&gt; reduce_comm (\(idx, x, v) (idx&#39;, x&#39;, v&#39;) -&gt;
                    if v &lt; v&#39; || x&#39;
                    then (idx, x, v)
                    else (idx&#39;, x&#39;, v&#39;))
                 ((-1, -1), true, f32.highest)
  |&gt; (.0)</code></pre>
<p>With these building blocks in place, let’s implement <code>initial_binary_pattern</code>. <code>ip</code> is the input pattern, and the result is the initial binary pattern.</p>
<pre class="futhark"><code>let initial_binary_pattern [n] (ip: *[n][n]bool): *[n][n]bool =
  let (_, _, res) =
    -- Initialize the two indices with invalid but different values
    loop ((i, j), (i&#39;, j&#39;), ip) = ((-2, -2), (-1, -1), ip)
    -- While the the two indices are different
    while (i, j) != (i&#39;, j&#39;) do
      -- Compute the location of the tightest cluster
      let (i, j) = tightest_cluster ip
      -- Set that location to false
      let ip[i, j] = false
      -- Compute the location of the largest void
      let (i&#39;, j&#39;) = largest_void ip
      -- Set that location to true
      let ip[i&#39;, j&#39;] = true
      -- Repeat
      in ((i, j), (i&#39;, j&#39;), ip)
  in res</code></pre>
<p>In order to compute the initial binary pattern, we need a random input pattern, which will be generated by the <code>rand_binary_pattern</code> function:</p>
<pre class="futhark"><code>module dist = uniform_int_distribution i64 minstd_rand

let rand_binary_pattern (seed: i32) (n: i64) (m: i64): [n][m]bool =
  let rng = minstd_rand.rng_from_seed [seed]
  -- Generate an n*m matrix with just `false` values
  let xss = replicate n (replicate m false)
  -- Generate a minority number of indices and set them to `true`.
  let rngs = minstd_rand.split_rng (n * m / 4) rng
  let (_, idxs, vals) =
    map (\rng -&gt;
           let (rng, y) = dist.rand (0, n) rng
           let (rng, x) = dist.rand (0, m) rng
           in (rng, (y, x), true))
        rngs
    |&gt; unzip3
  in scatter_2d xss idxs vals</code></pre>
<p>Finally, in order to visualize the smallish patterns, let’s write some functions to scale them up to arbitrary pixels sizes:</p>
<pre class="futhark"><code>let scale [n][m] &#39;t (n2: i64) (m2: i64) (img: [n][m]t): *[n2][m2]t =
  let y_scale = f32.i64 n2 / f32.i64 n
  let x_scale = f32.i64 m2 / f32.i64 m
  in tabulate_2d n2 m2 (\i j -&gt; img[i64.f32 &lt;| f32.i64 i / y_scale,
                                    i64.f32 &lt;| f32.i64 j / x_scale])

let scale_f32: (i64 -&gt; i64 -&gt; [][]f32 -&gt; *[][]f32) = scale

let scale_bool: (i64 -&gt; i64 -&gt; [][]bool -&gt; *[][]bool) = scale</code></pre>
<p>With all that in hand, let’s take a look at what a generated initial binary pattern could look like:</p>
<pre class="futhark"><code>let ibp = initial_binary_pattern (rand_binary_pattern 123 64 64)</code></pre>
<pre><code>&gt; :img scale_bool 200i64 200i64 ibp</code></pre>
<p><img src="bluenoise-img/3aa2086d49c724ee-img.png" /></p>
<p>That looks pretty good, I think! So now, let’s go about turning it into a blue noise pattern. The <code>bluenoise</code> function is a pretty straight-forward implementation of the algorithm as described in Ulichneys original paper:</p>
<pre class="futhark"><code>let bluenoise [n] (ibp: [n][n]bool) : [n][n]i32 =
  -- Load the binary pattern with the initial binary pattern
  let bp = copy ibp

  -- ones is the number of `true` values in the binary pattern
  let ones =
    flatten ibp
    |&gt; map i32.bool
    |&gt; i32.sum

  let rank = ones - 1

  -- `dit` is the result dither array we&#39;ll input values into.
  let dit = replicate n (replicate n 0i32)

  -- Phase 1
  let (dit, _, _) =
    loop (dit, bp, rank)
    while rank &gt;= 0 do
      let (i, j) = tightest_cluster bp
      let bp[i, j] = false
      let dit[i, j] = rank
      in (dit, bp, rank - 1)

  let bp = copy ibp
  let rank = ones

  -- Phase 2
  let (dit, bp, rank) =
    loop (dit, bp, rank)
    while rank &lt; i32.i64 (n * n / 2) do
      let (i, j) = largest_void bp
      let bp[i, j] = true
      let dit[i, j] = rank
      in (dit, bp, rank + 1)

  -- Invert the binary pattern, such that `false` are now the minority pixels
  let bp = map (map (!)) bp

  -- Phase 3
  let (dit, _, _) =
    loop (dit, bp, rank)
    while rank &lt; i32.i64 (n * n) do
      let (i, j) = tightest_cluster bp
      let bp[i, j] = false
      let dit[i, j] = rank
      in (dit, bp, rank + 1)

  in dit</code></pre>
<p>Let’s take a look:</p>
<pre class="futhark"><code>let bluenoise_mask = normalize (bluenoise ibp)</code></pre>
<pre><code>&gt; :img scale_f32 200i64 200i64 bluenoise_mask</code></pre>
<p><img src="bluenoise-img/576f9945c2f29d39-img.png" /></p>
<p>Looks pretty random to me. Let’s try to apply it to our images:</p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;dark-original.png&quot;)) bluenoise_mask</code></pre>
<p><img src="bluenoise-img/6a5f4c9349ea19ee-img.png" /></p>
<pre><code>&gt; :img dither (greyscale ($loadimg &quot;light-original.png&quot;)) bluenoise_mask</code></pre>
<p><img src="bluenoise-img/e0f27b617907cf50-img.png" /></p>
<p>Cool! I think I’ll leave this here for now. I have other work to do…</p>
<p>So long, and thanks for following along!</p>
</body>
</html>
